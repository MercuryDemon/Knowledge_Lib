08-09-2025 19:20
Tags: #Go #lesson 
# Планировщик

Некая сущность, которая управляет горутинами, распределяет их по потокам, и управляет потоками ОС.
- отделяет програмиста от ручного управления потоками и переключения контекста в рамках потока
- реализует конкурентный подход програмирования, где горутины конкурируют за исполнения на одном и более потоках. Реализует [[Ассинхронное програмирование]]

## Основы / Base

web разработка это в основном работа с input/output bound нагрузкой. Много смены контекста, обработка на одном потоке не одного пользователя, а обработка нескольких запросов от разных пользователей.

Ключевая идея:
- не даем в руки програмисту поток ОС
- Делаем вид, что есть толко горутинами
- Всю сложность распределения горутин абстрагируем

- N количесво горутин выполняются на одном потоке, они строятся в очередь (в случае одноядерного процессора)

- компилятор добавит места в исходный код для переключения контекста, то есть кусочки кода которые будут переключать контекст внутри одного потока ОС. Такие свичи контекста добавляются например в момент проверки  необходимого пространства для стека горутины (кооперативная многозадачность)


## Масштабирование / Scaling

Для того чтобы масштабировать идею выполнения нескольких горутин на одном потоке, для процессоров с множеством ядер (потоков), было произведено шардирование (разбиение на кусочки) очерени всех горутин на разные локальные очереди закрепленные за каждым потоком.

- потоки не конфликтуют за горутины

### GMP model

G - Goroutine (что исполняем)
M - Machine (где исполняем)
P - Processor (распределение прав и рессурсов для исполнения)

### Work Stealing

горутины созданные одним потоком, добавляются в локальную очередь этого же потока. Однако если у потока заканчиваются горутины в очерени, этот поток сам идет смотрит в очереди других и пиздит оттуда горутины себе в очередь.

![[Pasted image 20250908202753.png]]

- очередь откуда красть горутины выбирается рандомно
- пробуем украсть 4 раза (если в локальной очереди откуда пытаемся стащить горутину не горутин)
- Пиздим половину горутин( чтобы как можно реже ходить по очередям, потому что каждый поход за горутинами стопорит поток)

## Syscalls / Системные вызовы

- Когда поток делает Syscall он обращается в ядро(прыжок в ядро), сам поток блокируется

### HANDOFF

принцып при котором если какаято горутина обращается к ядру, тогда создается новый поток, который будет выполнять эту горутину. А прежний продолжает выполнять горутины из очереди.
Однако создавать новый поток достаточно долго.

![[Pasted image 20250908204048.png]]

Поэтому в Go существует отдельный поток sysmon (системный монитор) который следит за тем, какие syscall_ы вызываются. 
- Если вызываюся syscall_ы которые будут выполненны быстро (short-lived syscalls), тогда блокируется один поток вместе с очередью, и после выполнения системного вызова он разблокируется.

- Если вызываюся syscall_ы которые(возможно) будут выполняться долго, тогда происходит вышеописанное.

- Кроме того, потоки в  которых горутина выполняла syscall не удаляются а сохраняются в зарезервированные потоки, после чего могут выполнить новый syscall или перехватить часть горутин из локальных очередей других потоков.

- после выполнения syscall_а горутина возвращается в очередь потока где была изначально, однако если поток заблокирован другим syscall-ом или очереди всех потоков переполнены тогда горутина добавляется в глобальную очередь (global queue)

- примитив синхронизации, в глобальной очереди - Mutex


## Очереди / Queue

- В качестве примитива синхронизации в локальной очереди  Go выбран lock-free в угоду быстродействию 

Как и когда берутся горутины из глобальной очереди?

![[Pasted image 20250908214506.png]]
1 раз за 61 обращение к планировщику поток идет забирать горутины из глобальной очереди

Очередь в Go строится по принципу FIFO (first in - first out) c однокомпанентной пристройкой очереди LIFO (lust in - first out)
![[Pasted image 20250908215111.png]]

Как быть если две горутины надолго ставят друг друга в LIFO?  - Sysmon имеет таймаут на такую операцию


## Синхронизация / Synchronization

В Go самописные mutex для отдельных горутин. Вместо обращения к планировщику ОС за мьютексом, мы обращаемся к планировщику Go

Есть состояния горутин:
- Running - выполняется
- Runnable - готова к выполнению
- Waiting - остановлена и чего-то ждет

Для ожидающих горутин существует WAIT QUEUE. Все горутины состояния Wating отправляются сюда.

### Starvation mode

![[Pasted image 20250908220205.png]]
например если одна горутина собирается освободить мьютекс а вторая хочет его взять, и также есть горутина в wait queue, которая тоже хочет взять мьютекс тогда:
- В нормальном режиме вторая горутина перехватывает мьютекс, а горутина в wait queue остается спать.

- Если горутина в wait queue висит дольше таймаута, горутина освобаждающая мьютекс явно передаёт горутине из wait queue мьютекс. А вторая ждет пока освободится мьютекс.

## Циклы / Loops

Для безконечных циклов и CPU-Bound задач используем вытеснением горутины
![[Pasted image 20250908221059.png]]
Горутина может быть вытеснена несразу, так как она может находиться в unsafe пространстве памяти. Как только ее выполнение дойдет до safepoint она может быть вытеснена другой горутиной.



### Zero-Links
- [[00 Golang]]
- [[00 Обучение]]


### Links
- https://youtu.be/P2Tzdg8n9hw?si=3YUHhFj_GpiXnKW-
- 

