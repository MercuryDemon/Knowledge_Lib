19-05-2025 23:56
Tags: #z #lesson 
# Временная сложность
## Что такое оценка сложности O(n)
 
Это ==оценка скорости роста времени обработки== данных алгоритмом при увеличении количества входных данных.


==Элементарный шаг== - любой кусок кода(любая часть алгоритма) время выполнения которого не меняется от количества входных данных.
пример элементарного шага - одна ==итерация== цикла "for"

В нотации O(большого) константы опускаются

## Линейная сложность O(n)

Время работы функции прямо пропорционально количеству элементарных шагов.

Например функция поиска максимального значения переменной в массиве. Чем больше элементов подаём на вход, тем большее количество элементарных шагов будет выполнять алгоритм, следовательно тем больше времени будет уходить на вычисление.

![[поиск максимума массива O(n).png]]

зависимость линейная - по этому и сложность линейная.

второй пример, последовательный поиск элемента с заданным значением
![[последовательный поиск O(n).png]]
- худший случай нам придется пройти до конца массива сравнивая элементы
- лучший случай пройти один шаг
- а в среднем придется пройти половину массива

Отсюда и следует что сложность такого алгоритма будет O(n/2), однако при увеличении входных данных ==скорость роста== времени бработки будет всё равно будет зависеть линейно. по этому O(n/2) = O(n)

## Константная сложность O(1)

Время работы функции не зависит от размера входных данных.

пример - выбор среднего элемента массива

![[выбор среднего элемента массива O(1).png]]

ну совсем не зависит, мы просто тыкаем в центр т.е. совершаем всегда только один элементарный шаг.

## Логарифмическая сложность O(log(n))

сразу пример - бинарный поиск

![[бинарный поиск O(log(n)).png]]

Суть в том, что после каждого элементарного шага массив обрабатываемых данных сокращается в 2 раза. алгоритм работает пока не останется один элемент.

например массив из 1024 элементов можно последовательно поделить на 2 всего 10 раз.

логарифм это обратное возведению в степень математическое преобразование!

основание логарифма не важно

##  Логарифмическая с умножением на n O(n * log(n))

Пример - быстрая сортировка

![[быстрая сортировка O(n *log(n)).png]]

Алгоритм производит log(n) итераций и на каждой такой итерации обрабатывается n элементов.

## Квадратичная сложность O(n^2)

это вообще пиздос

вложеный цикл, то есть выполняется n итераций внутри каждой из которой обрабатывается n(или m) элементов.
(шагаем по двумерному массиву например)

Пример - сортировка выбором

![[сортировка выбором O(n в квадрате).png]]

## Кубическая сложность O(n^3)

три вложенных цикла

## Степенная сложность O(2^n)

Пример - перебор n-разрядных чисел

![[перебор n-разрядных чисел O(2 в степени n).png]]

## Факториальная сложность O(n!)

Пример - перебор перестановок

![[перебор перестановой символов O(n!).png]]


# Пространственная сложность

пространственная O(n) - оценка скорости роста объёма оперативной памяти с увеличениемколичества входных данных.

## Константная пространственная сложность.

Пример - функция вычисления максимумального значения элемента в массиве

В такой функции, дополнительная память используется только для хнанения пары temp(временных) переменных. 

Обьём выделение памяти никак не увеличивается с ростом объёма входных данных.

## Линейная пространственная сложность

что логично - скорость роста объёма выделенной памяти пропорциональна увеличению количества входных данных

Пример - функция получает на вход массив чисел и создает вспомогательный массив.

чем больший массив прилетит на вход функции, тем больше памяти резервируется под вспомогательный массив.

## Логарифмическая пространственная сложность

такая сложность возникает в программах где используется рекурсия.

например - бинарный поиск, где мы после каждого рекурсивного вызова функции перезаписываем временную переменную.

получается, что каждый скорость роста объёма выделенной оперативной памяти зависит от глубины рекурсии.
 

### Zero-Links
- [[00 Обучение]]
- [[00 Алгоритмы]]
- [[00 Data Struct]]
-

### Links
- https://www.youtube.com/watch?v=qOO7IAZw_sk
- 

