01-12-2025 18:06
Tags: #Go #lesson #z #DB 

# Термины

Cache miss - промах кэша, запрошенный ключ не найден в кэше

Сache hit - попадание в кэш, запрошенный ключ найден в кэше

Hit ratio - процент попадания в кэх, характеризует эффективность кэширования.

Горячий ключ - ключ, на который приходится большая часть запросов

Прогрев кэша - поцесс наполнения кэша данными

Инвалидация - удаление кэшированнфх данных

 

# Что ткое кэширование



- кэшируем только данные которые хранятся долго

- можно кэшировать ошибки
# Зачем применять

- Сокращение response time сервисов
- снижение загрузки на сторонние сервисы
- переиспользование ранее полученых или вычисленных данных
- стабилизация работы при кратковременных отказах систем


# Виты кэширования


## Внутреннее кэширование

- внутрянняя структура данных
- находится рядом с сервисов (в опкративке)

Плюсы:
- Высокая скорость
- Отсутствие сетевых запросов
- нет расходовна marshaling/Unmarshaling данных

Минусы:
- Горизонтальное масштабирвание (трудновыполнимо)
- прогрев кэша после падения сервиса


## Внешнее кэширование

- кэш кранится во внешнем сервисе

Плюсы: 
- хранение большого обьема данных
- простое горизонтальное масштабирование
- после падения сервиса кэши не теряются
- простой прогрев кэша и простая логика инвалидации

Минусы:
- сравнительно медленная скорость работы (как у меня)


# Способы взаимодействия с кэшем

## Cache aside

В этой стратегии взаимодействия приложение координирует запросы в БД и само решает, куда и в какой момент нужно обращаться

запрос на чтение: 
![[Pasted image 20251201184119.png]]
(lazy caching)

запрос на запись данных:
![[Pasted image 20251201184227.png]]


## Cache through

Все данные и запросы идут через кэш

запрос на чтение:
![[Pasted image 20251201184531.png]]

запрос на запись:
![[Pasted image 20251201184836.png]]

плюсы:
- сервис ничего не знает про дазу данных

минусы:
- если кэш упал - приложение не доступно, так как оно знает только про кэш

## Cache ahead

опережающее кэширование - запросы на чтение всегда идут только в кэш

- приложение работает только с кэшем, и в сам кэш периодически загружаются данныз из БД

![[Pasted image 20251201190045.png]]

Плюсы:
- очень(реально) быстрое чтение

минусы:
- если кэш упал, прилога не получит данных пока они не подгрузятся в кэш из БД



# Алгоритмы вытеснения данных(из кэша)

Алгоритмы вытеснения отвечают за отределение тех данных которые следует вытеснить для того чтобы заменить их другими данными

## Random

Рандомное вытеснение - буквально на приколье рандомно выбираем (так никто не делает).

## FIFO

First in - first out - обычная очередь, вытесняются данные которые были добавлены первыми.

## LIFO 

Last in - first out - стек последние добавленные данные вытесняются.

## LRU

Least recently used - вытесняется элемент к которому дольше всего небыло обращений.

## MRU

Most recently used - вытесняется тот элемент к которому обращались последний раз.

## LFU

Least frequently used - вытесняиется элемент к которому меше всего обращались(значит у каждого элемента должен быть счетчик обращений)

## OPT(Алгоритм Белади)

- вытесняется тот элемент к которому обратятся через наибольшее время в будущем)
- теоретический алгаритм (не применим на практике)

## Second chance

- По сути очередь которая дает второй шанс элементам которые были использованы, к таким элементам добавляется 1-бит флаг, где 0 - unused, 1 - used.
- при необходимости вытеснения элемента алгоритм идет по очереди и если видит такой флаг, он его сбрасывает и ставит элемент в конец очереди. Если флага нет элемент вытесняется.

![[Pasted image 20251201192931.png]]

## Clock

То же самое что Second Chance, только алгоритм не перемещает элемент в конец очереди, так как очередь зациклена, а просто сбивает флаг "used"

![[Pasted image 20251201193650.png]]


## 2Q

- Есть 2 очереди FIFO и буфер LRU.

![[Pasted image 20251201194224.png]]

## SLRU(Segmented LRU)

3 уровня LRU - cold, warm, hot

![[Pasted image 20251201194544.png]]

## TLRU (Time aware LRU)

Такой же как LRU алгоритм но у элементов есть TTL - time to live, по которому они автоматически удалябтся из кэша.

## LRU-K

Удаляет элемент, К-тый последний доступ к которому находится дальше всего в прошлом.

- LRU-1 - это просто LRU
- LRU-2 - удаляет элементы в соответствии со временем их предпоследнего доступа.


# Инвалидация данных в кэше

## Инвалидация по TTL

При добавлении дашнных в кэш им устанавливается TTL - time to live, и данные будут автоматически удалены через это время.

- чем меньше TTL тем менее прогрет кэш, зато актуальность(консистентность) данных выше.

**JITTER** - если много элементов инвалидируется одновременно их надо обновить сделав повторный запрос  в БД. Если много запросов придет одновременно, то БД может лечь. JITTER позволяет рандомно скорректировать время в заданных рамках для каждого элемента. Таким образом размазываем нагрузку на БД по времени.

### Thundering herd problem

Проблема стада быков(вольная локализация) - резкая нагрузка на БД когда множество процессов одновременно запрашивают один ключ кэша, получают cache miss, а затем все выполняют один и тотже запрос.

- решается мьютексом, когда идет одновременное обращениек одному элементу кэша

## Инвалидация по событию

При изменении данных в БД Кэши оповещаются об этом и инвалидируют данные
- оповещаются например брокером сообщения (kafka, rabitMQ и т.д.)
![[Pasted image 20251201201010.png]]

## Версионирование КЭША

![[Pasted image 20251201201415.png]]

## Тегирование КЭША

Каждому элементу добавляется тэг, если брокер сообщений присылает какой-то тег, инвалидируются элементы с таким тегом (так сказать все причасные)



# Многомерный КЭШ

Когда идет обращение к какому либо сервису...
![[Pasted image 20251201202357.png]]













### Zero-Links
- [[00 SQL]]
- [[00 Data_Base]]
- [[00 Обучение]]


### Links
- https://www.youtube.com/watch?si=Fvh09EmVerOJnsvv&v=iLMlYgQoTIE&feature=youtu.be

