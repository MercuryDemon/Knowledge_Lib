24-11-2025 20:28
Tags: #DB  #lesson 
# Шардирование
Шардирование - разделение базы данных на несколько независимых частей шардов(shard -осколок)


## Зачем нужно шардирование.

Когда нагрузка на БД возрастает, возникает постребность масштабирования БД. 

Моно масштабироваться:
- Горизонтально - увеличивать количество железа, которое обслуживает базу данных
- Вертикально - ...

Шардирование помогает оптимизировать хранение данных приложения за счёт их распределения между инсталляциями БД (которые находятся на разных железках), что улучшает отзывчивость сервиса, так как размер данных в целом на каждом инстансе станет меньше.

Шардирование — это разновидность партиционирования (от англ. _partition_ — деление, раздел). Отличие в том, что партиционирование подразумевает разделение данных внутри одной БД, а шардирование распределяет их по разным экземплярам БД.

## Способы шардирования
1) **Средствами БД**. Некоторые базы — MongoDB, Elasticsearch, ClickHouse и другие — умеют самостоятельно распределять данные между своими экземплярами, для этого достаточно настроить конфигурацию.
2) **Надстройками к БД**. Самый спорный способ — применение надстроек, которые выполняют шардирование, например Vitess или Citus, поскольку при этом есть риск потери данных и производительности.
3) **Клиентскими средствами**. В этом случае экземпляры БД даже не подозревают о существовании друг друга, шардированием управляет стороннее приложение — со всеми вытекающими рисками.

- важно понимать зачем шардировать, чтобы правильно распределить нагрузку между шардами



# Репликация

**Репликация** - процесс изменения одного набора данных, называемого репликой, в ответ на изменения другого набора данных, называемого основным

Реплика - живой клон БД, который изменяется вместе с изменением оригинальной БД

## Зачем нужна репликация

- Поддержка основной БД на случай выхода её из строя
- Снижение нагрузки на основную БД путём переноса части запросов на реплики
- перенос данных в архивные или аналитические системы


## Подходы к репликации

1) Блочная репликация на уровне системы хранения данных
2) Физическая репликация на уровне СУБД
3) Логическая репликация на уровне СУБД

### Блочная репликация

При блочной репликации каждая операция записи выполняется не только на основном диске, но и на резервном. Таким образом тому на одном массиве соответствует зеркальный том на другом массиве, с точностью до байта повторяющий основной том:
![[Pasted image 20251124205835.png]]

**Достоинства**
- простота настройки
- надёжность

**Минусы**
- Нет возможности обратиться к зеркальному тому (в случае отказа основного все надо поднимать вручную)
- Медленный старт реплики БД + пустой кэш после рестарта
- Восттановление консистентности БД при запуске резервного тома займёт кучу времени

### Физическкая репликация

Журналы (redo log или write-ahead log) содержат все изменения, которые вносятся в файлы базы данных. Идея физической репликации состоит в том, что изменения из журналов повторно выполняются в другой базе (реплике), и таким образом данные в реплике повторяют данные в основной базе байт-в-байт.

**Преимущества**
- объём передаваемых данных меньше за счёт того, что передаются только журналы, но не файлы с данными; эксперименты показывают уменьшение трафика в 5-7 раз;
- переключение на резервную базу происходит значительно быстрее: экземпляр-реплика уже поднят, поэтому при переключении ему нужно лишь откатить активные транзакции; более того, к моменту сбоя кеш реплики уже прогрет;
- на реплике можно выполнять запросы, сняв тем самым часть нагрузки с основной базы. В частности, реплику можно использовать для создания резервных копий.

**Минусы**:
- Нельзя писать данные в реплику напрямую (всё идет через мастер БД)


### Логическая репликация

Все изменения в базе данных происходят в результате вызовов её API – например, в результате выполнения SQL-запросов. Очень заманчивой кажется идея выполнять одну и ту же последовательность запросов на двух разных базах. Для репликации необходимо придерживаться двух правил:
1. Нельзя начинать транзакцию, пока не завершены все транзакции, которые должны закончиться раньше.
2. Нельзя завершать транзакцию, пока не начаты все транзакции, которые должны закончиться до завершения текущей транзакции. 

**Преимущиства**:
- настройка набора реплицируемых данных на уровне таблиц
- построение сложных топологий репликации – например, консолидация нескольких баз в одной или двунаправленная репликация
- уменьшение объёма передаваемых данных
- репликация между разными версиями СУБД или даже между СУБД разных производителей
- обработка данных при репликации, в том числе изменение структуры, обогащение, сохранение истории


**Минусы**:
- все реплицируемые данные обязаны иметь первичные ключи
- логическая репликация поддерживает не все типы данных – например, возможны проблемы с BLOB’ами
- логическая репликация на практике не бывает полностью синхронной: время от получения изменений до их применения слишком велико, чтобы основная база могла ждать
- логическая репликация создаёт большую нагрузку на реплику
- при переключении приложение должно иметь возможность убедиться, что все изменения с основной базы, применены на реплике – СУБД зачастую сама не может этого определить, так как для неё режимы реплики и основной базы эквивалентны


Есть несколько способов реализации логической репликации, и каждый из этих способов реализует одну часть возможностей и не реализует другую:  
  
- репликация триггерами;
- использование журналов СУБД;
- использование программного обеспечения класса CDC (change data capture);
- прикладная репликация.



### Zero-Links
- [[00 Обучение]]
- [[00 Data_Base]]


### Links
- https://www.youtube.com/watch?v=QgIWHeNy8fA
- https://habr.com/en/amp/publications/705912/
- https://habr.com/en/articles/514500/

