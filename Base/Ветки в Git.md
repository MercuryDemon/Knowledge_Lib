05-06-2025 20:21
Tags: #z #lesson 
# Ветки

Ветка - отдельный. изолированный поток разработки проекта.

Тематические ветки - новые фичи и идеи разрабатываются параллельно, потом вливаются когда готова в остновную ветку.

Релизные ветки - ветки можно использовать для допиливания и поддержки какихто версий проекта для их релиза.

Cherry picking - удачный коммит одной ветки можно применить его изменения к другой.

git flow - подход к ведению проекта в котором сочетаются теметические и релизные ветки.

!! Ветка указывает на последний сделанный в ней коммит. 
# Создание и переключение

`git branch` или `git branch -v` - команды просмотра веток.
флаг `-v` показывает на какой коммит ссылается.

`git branch branchName commitId*`  - создаем ветку branchName
`*optional`

`git checkout branchName` - переключаемся на ветку branchName

## незакоммиченный чекаут

если мы внеси изменения в файл, но не закоммитили, и захотим перейти в другую ветку. Гит выдаст ошибку, и не даст нам это сделать.

допустим мы не можем закоммитить, потому что ещё не закончили.

тогда варианты:
- если изменения не нужны, прибавляем к чекауту флаг `--force`. в таком случае изменения удаляются и мы переходим в новую ветку.
- если изменения важны, делаем `git stash`. Эта команда собирает незакоммиченные измененя, удаляет их из файлов и архивирует в специальном виде в гит. Чтобы вернуть изменения в файлы `git stash pop`.

!можно сохранить гит стеш на одной ветке, а применить на другой. (использовать супер осторожно)

Если файл в ветках различается/был удален тогда ошибка
Если файл одинаковый переключается с кайфом

# Перенос незакоммиченных изменений.

Если мы наворотили говнокода в мастер ветке и он даже наботает, но его нельзя назвать идеальным. Мы хотим закоммитить но в матер нельзя, мы можем через чекаут с флагом `-b fix` создать другую ветку с именем fix. Она будет пока что также указывать на последний коммит что и мастер, и по этому мы можем в нее переключаться без конфликтов с нашими измененными файлами. 

Коммитим в ней. А в мастере чистим ебулду навороченную.


Если мы наворотили и уже несколько раз закоммитили в мастере, а потом поняли что всё это какаято шляпа, мы можем припомощи чекаута создать новую ветку, а при помощи - `git branch -f master идентификатор коммита/имя ветки` - переместить мастер на несколько коммитов назад. 

Закоммиченные изменения остаютсяв созанной новой ветке.

идентификатор коммита можно посмотреть в логах гита

То же самое можно сделать `git checkout -B branchName commitId/branchName1`


# Состояние отделенной HEAD

При помощи чекаута можно перейти не только к ветке, но и на любой КОММИТ!

Возникает состояние отделённой HEAD.

Git будет ругаться и предложит создать отдельную ветвь от коммита к которому мы перешли.

`cherry-pick commitId` чтобы скопировать изменения с какого либо коммита на ветку в которой находимся.

# Восстановление прежней версии файла

Если хотим достать старую версию файла из старого коммита делаем: 
`git checkout commitId/branchName fileName`.

Файл автоматически добавляется в индекс в текущей ветке.

`git reset fileName` - если хотим удрать из индекса.

# Просмотр логов

`git log` - полный лог, флаг `--oneline` - упрощённый лог/
`git log branchName --oneline` - лог определённой ветки.

`git show commitId :fileName`  - посмотреть что было в файле на такомто коммите

`git show :/someKeyWord` - можем посмотреть самый свежий коммит в описании которого есть someKeyWord


# Слияние веток "перемоткой"

находясь в ветке вводим `git merge brunchName`. 
Вернуть все как было `git brunch -f master ORIG_HEAD`

Перемотка(fast-forward) в случае если мастер не изменялся и какая-то ветка растёт из верхушки мастера. При этом методе мастер просто начинает указывать на верхушку той ветки которую мёрджим.


# Удаление Веток

Ну вот мы слили ветки, осталась лишняя отработанная. Удаляем ветку:
`git branch -d branchName` - удаляется ссылка ветки, а сами коммиты остаются в Git.

прокатит только если ветка объеденина с текущей, если мы из текущей захотим почикать какуюто другую вылезет ошибка.

Если в вышеописанной команде флаг `-D`, ссылка на стороннюю вету удалится

коммиты ссылка на которые удалена(удалена ветка) называются недостижимые.


# Лог ссылок reflog

`git reflog` - красивый вывод логов взаимодействия с сылками(ветками)

по reflog можно найти недостижимые коммиты.

рефлоги хранятся локально, при передаи ветки на сервер рефлоги не переносятся.

# Удаление мусора и незакоммиченных изменений.

`git reset hard` - почистить всё незакоммиченное.

`git clean` - удаление неотслеживаемых файлов, флаг `-d` - удаляет и дерриктории, флаг `-x` - удаляются файлы игнорируемые через .gitignore, 
флаг `-f` - без этого не работает(мы уверены что всё надо почикать)

# Удаление коммитов reset --hard

`@` - сокращение HEAD
`~` - сокращение 1 коммит назад
`~n` - n коммитов назад

`git reset --hard commitId` - до какого коммита откатываемся

`git reset --hard ORIG_HEAD` - вернуть всё как было

# reset --soft

`git reset --soft @~ - Перемещает состояние ветки на один коммит назад.

Отменяет поcледний коммит, отавляет все данные подготовленные к коммиту в индексе.

Используется для изменения последнего коммита.

для того чтобы применить то же описание, что было в коммите который откатили назад применяем:
`git commit -c ORIG_HEAD` если подправить описание об авторе, и флаг `-C` - если копирем описание полностью. (так можно делать с описанием от любого коммита, главное знать его идентификатор или ссылку)

# commit --amend

одна команда позаоляющая внести изменения в описание коммита (как в пункте выше)
`git commit --amend` - перкоммит( по сути откатывает коммит, оставляет изменения в индексе, на основе изменений и описания старого клммита создаёт новый и открывает редактор описания) старый коммит становится недостижимым и потом когданибудь удаляется.

# Reset без флагов

переносится ссылка ветки на указанный коммит, сбрасывает индекс но оставляет изменения в рабочей директори.

точечно сбрасывает из индекса указанные файлы или все файлы при указании HEAD


# git diff

`git diff commitId1/link commitId2/link` - сравнивает изменения между содержанием фалов отрывками(ханками) 

`git diff master...feature` - показывает что именно изменилось в  ветке фичер начиная от момента  расхождения нее с веткой мастер(относительно момента создания ветки фичер)

`git diff HEAD` или просто `git diff` сравнение изменений неиндексированных файлов в рабочей дирректории с последним коммитом.

`git diff --staged` - сравнение индекса с последним коммитом (HEAD)


# Вычисляем пидараса git blame

Если вы видите непонятный участок говнокода, можно вычислить кто его написал 
`git blame fileName` - с указанием имени файла сожно посмотреть кто и в каком коммите написал каждую строку в файле.



# Истинное слияние, разрешение конфликтов

- перед слиянием статус должен быть чистым.
- 
находясь в ветке master выполняем `git merge faeture` при этом происходит следующее:
1. Git ищет коммит где ветки разошлись merge-base, 
2. берет за осову файл из базового коммита
3. добавляет в него изменения последовательно сначала из нашей версии(головного коммита ветки откуда выл вызван merge), а затем из сливаемой ветки
4. создает коммит новый коммит со всеми изменениями во всех файлах и переносит ссылку мастер на новый коммит (ссылка ветки feature остается по последнем перед слиянием коммите)

возникают ситуации когда изменения конфликтуют между собой.
гит отмечает в файле места конфликта.

В таком случае процесс слияния остановится 
для его возобновления в файле нужно
- внести изменения, разрешающие конфликт.
- добавить измененный файл в индекс `git add fileName`
- и возодновить слияние `git merge continue` или просто закоммитить `git commit`

Получается коммит слияния у него 2 родительсикх коммита!

1 родитель - куда вливалось
2 родитель - то что вливалось

`git diff HEAD^1` или  `^` обозначает изменения коммита относительно его первого родителя, `^2` - изменения относительно второго.


# Отмена слияния

Вариант - жеский ресет на шаг назад `git reset --hard @~` (откатываем коммит на предыдущий)

последний коммит-слияния становится недостижимым


# Семантические конфликты и их разрешение

В случае если мы предполагаем что при слиянии возникнут смысловые ошибки в коде, и на выходе мы получим нерабочий код. 

Мы сливаем не делая коммита c флагом `--no-commit`

Git проведет слияние, добавит всё в индекс и остановится перед коммитом.

В это время можно протетировать слитые файлы на их работоспососбность, и в случае чего исправить и заново добавить изменения в индекс.

затем снова запустить `git merge` для продолжения слияния.

# Флаг `--no-ff`

в случае если предполагается слияние перемоткой, но нам важно сохранить историю отдельной ветки делаем merge  с флагом `--no-ff`
`git merge --no-ff`

`git config merge.ff false` - если хотим чтобы так было по умолчанию


# `--squash`

`git merge --squash branchName` - если хотим упаковать все изменения в ветку в которую сливаем из другой, но нам не нужна и истори вливаемой ветки ни связь с ней как со второй родительской.

изменения из другой ветки просто добавляются в индекс например мастера

затем делаем коммит и это просто новый коммит мастера никак не свяанный с верткой branchName





### Zero-Links
- [[00 VCS(Git)]]
- [[00 Обучение]]



### Links
- https://youtube.com/playlist?list=PLDyvV36pndZFHXjXuwA_NywNrVQO0aQqb&si=JP73YQ0ImG6JiSRH

