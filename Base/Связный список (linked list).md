20-05-2025 22:11
Tags: #z #lesson 
## Структура связного списка

Это как массив, только в массиве данные хранятся в памяти последовательно, а в связанном списке они находятся в разных частях памяти звеньями. 

При чем длина звеньев может быть разной, но в конце каждого звена выделена отдельная ячейка памяти, которая хранит указатьль на начало следующего звена.

![[LinkedList суть.png]]

head - голова связного списка
tail - конец связного списка

Это все односвязный список

Двусвязный список имеет связь как со следующим звеном так и с предыдущим.

## Операции со Связным списком

### 1. Вставка в начало/удаление из начала.

Для вставки - создается новый элемент массива который будет указывать на адрес head текущего массива, и меняется адрес head на адрес нового первого элемента.

для удаления, запоминаем элемент который хотим удалить, меняем адрес head на адрес элемента следующего за первым элеменом, и чистим память в тех ячейках где только что был первый элемент.

СЛОЖНОСТЬ КОНСТАНТНАЯ O(1) АХУЕТЬ!!!

### 2. Вставка/удаление в конец

Тоже все просто - создаем элемент делаем так чтобы последний элемент в текущем массиве указывал на адрес созданного, и меняем адрес tail на адрес созданного элемента

удаление...

нуууу, нам либо надо найти предпоследний элемент, то есть пройти по всей цепочке от начала и до конца, каждый раз записывая временный адрес предыдущего элемемента - но это УЛЬРАКРИНЖ
Сложность такого алгоритма линейная O(n).

либо хранить второй указатель на предыдущий элемент Но это уже двусвязанный список))).

а далее

меняем адрес tail на предпоследний элемент, забываем последний элемент))).

### 3. Вставка/удаление в середину

![[Вставка в середину LinkedList.png]]

Вставка - создаём элемент, в предыдущем элементе указываем на адрес созданного элемента, в созданном элементе  указываем на адрес следующего.

Удаление - в элементе, идущем перед тем, который хотим удалить, указываем на адрес следующего за ним же. чистим память.
Сложность константная O(1).
### 4. Индексирование

Данные хранятся не последовательно, мы не можем использовать арифметику указателей.
По этому придется гулять по всему списку, чтобы дойти до элемента с определенным индексом.

Сложность линейная O(n).

## Построение связного списка

//Создаём отдельные звенья
Node* first := new Node(3, null) 
Node* second := new Node(1, null)
Node* third := new Node(1, null)

//говорим звеньям указывать на следующие 
first.next = second 
second.next = third
### Zero-Links
- [[00 Обучение]]
- [[00 Data Struct]]
- 


### Links
- https://www.youtube.com/watch?v=R8tvJOq0-14

