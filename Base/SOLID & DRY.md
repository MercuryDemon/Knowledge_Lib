23-10-2025 19:54
Tags: #Go #lesson
# Основы

SOLID - набор правил, подходов и принципов и ограничений в разработке ООП проекта.

Какой код является хорошим:
1. Масштабируемость, легко вносить изменения.
2. низкий порог вхождения, новым людям легко вникнуть в проект
3. Простой код, код не должень быть излишне усложнен, должен легко читаться.



# S - SINGLE RESPONSIBILITY

Принцип единственной ответственность.
- каждая отдельная сущность делает чтото одно. один класс/модуль/packege - одна задача.
- Декомпозируем все задачи на мелкие отдельные.

- не допускать возникновения God  class.

- не стоит упарываться в крайности

плюсы подхода:
- декомпозиция, разбили большую задачу на модули
- изменение в отдельном модуле не порушит всю логику
- метод/сущность инкапсулирует реализацию подзадачи
- можем использовать парралельную разработуку
- такие модули проще покрывать тестами

# O - OPEN CLOSED

Принип открытости/закрытости - *сущности должны быть открыты для масштабирования и закрыты для изменения*

- стремимся добавлять функционал, не за счет изменения существующих сущностей, а за счет добавления новой через компазицию, наследования и т.д.
- следует заранее задуматься о добавлении какого-то функционала , чтобы потом не костылить
 
 плюсы:
- нет необходимости в регремссиионном тестировании - не ломаем старый код, значит не нужно проверять
- меньше вероятность ошибок

# L - LISKOV SUBSTITUTION

Принцип подстановки Лисков (Барбары Лисков)
Наследуемый класс должен дополнять, а не замещать поведение родительского класса

методы определенные в родителтском классе должен также работать в наследуемом классе, наследуемый класс не переопределяет поведение


# I - INTERFACE SEGREGATION

Принцип разделения интерфейсов
- программные сущности не должны зависеть от методов, которые онги не используют.

- суть в том, чтобы разбивать большие интерфейсы на множество мелких, которые решают одну задачу

- нельзя заставлять клиента реализовывать интерфейс который он не использует.
![[Pasted image 20251023205742.png]]
Один интерфейс с 3 методами который реализуют другие сущности(структуры) разделен на 3 интерфейса, где у каждого 1 метод.

Плюсы:
- избавляем программные сущности от методов, которыеони не используют
- получаем более предсказуемую работу
- код снановится менее связанным

# D - DEPENDENCY INVERSION

Принцип инверсии зависимостей.

Модули высокого уровня не должны зависеть от модулей более низкого уровня, все они долны зависеть от абстракций, а абстракции не должны зависеть от деталей, детали должны зависеть от абстракций.

если проще:
модули высокого уровня не должны зависеть от модулей низкого уровня, между ними всегда нужна абстракция.


# DRY

- Надо избегать повторения одного и того же кода в разных частях вашей программы. Когда логика дублируется, любое изменение в ней требует обновления во всех местах, где она встречается.
пример несоблюдения:
```Go
package main

import "fmt"

type User struct {
   Name string    
   Age  int
   }

func (u User) PrintName() {
    fmt.Println(u.Name)  
}

func (u User) PrintAge() {
	fmt.Println(u.Age)  //функционал дублируется в разных методах

func main() {
    user := User{Name: "Alex", Age: 30}
    user.PrintName()
    user.PrintAge()
}
```

соблюдение:
```Go
package main

import "fmt"

type User struct {
   Name string    
   Age  int
   }

func (u User) PrintInfo() {
    fmt.Printf("Namr: %s, Age: %d\n", u.Name, u.Age)  
}

func main() {
    user := User{Name: "Alex", Age: 30}
    user.PrintInfo()
}
```

### Zero-Links
- [[00 Golang]]
- [[00 Обучение]]
- [[00 Computer science]]


### Links
- https://www.youtube.com/watch?v=TxZwqVTaCmA
- https://habr.com/en/companies/otus/articles/786314/

