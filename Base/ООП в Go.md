<<<<<<< HEAD
02-06-2025 20:54
Tags: #z #lesson 
# Объектно ориентированное програмирование


Методология програмирования в которой программа это совокупность обьектов реализующие какие-либо методы.
 - обекты являются экземплярами класса
 - классы имеют иерархическую систему наследования признаков и поведения обьектов. (типа как в биологии с животными)

Класс - это набор полей и методов объекта, кототрые описывают его свойства и поведение.

Класс описывает:
- Свойства (атрибуты ) и состояние обьекта
- операции, доступные для взаимодействия с данными(методы)
- Структуры данных обьекта

Объект - экземпляр конкретного класса с заданным состоянием(данными) и поведением(методами)

Новый объект инициализируется функцией конструктором
```go
type Person struct {
		Name string
		age int
}

func NewPerson(name string, age int) *Person { // функция конструктор
	return &Person{
		Name : name,
		Age : age,
	}
}

func main() {
	person1 := NewPerson("Никита", 25) // использование конструктора
}
```
Если не хотим чтобы вызывающая сторона не могла вносить изменения в структуру, возвращаем ее не по указателю а по значению.

# Отношения между объектами

В этом разделе объекты - сущности в программе(классы, структуры и т.д)

Виды отношений:
	is-a(является)
	has-a(иемеет, содержит в себе)

## Ассоциация (has-a)

Ассоциация - отношения между объектами при которых один может вызывать другой, для выполнения действия от его имени. При ассоциации оъекты не связаны, отношения могут быть как однонаправленными, так и двунаправленными(когда оба объекта знают о существовании другого).

### Агрегация (has-a)

Отношение - "часть-целое", один обьект содержит другой, но последний может существовать отдельно. Пример - водитель использует машину, но она может существовать отдельно и иметь несколько владельцев.

Агрегация в Go - встраивание одной структуры в другую в качесве одного из полей. Поля и методы внутренней структуры не доступны через внешнюю.
```go
type Car struct {
	Make string
	Color  string
}

type Driver struct {
	Name string
	Car Car
}

func main() {
	driver := Driver{Name : "Гаджишка", Car{Make : Lada, Color Black}}

	fmt.Println(driver.Name) // Гаджишка
	fmt.Println(driver.Car.Make) // Lada
	fmt.Println(driver.Color) // ошибка (но вообще он такойже черный как его Лада чурка)
}
```

### Композиция (has-a)

Строгая зависимость, при компазиции объекты существуют только в контексте друг друга. Один неотъемлемая часть другого.

Реализуется встраиванием одной структуры в другую, но теперь без явного указания имени. При этом поля внутренней структуры доступны через внешнюю.
```go
type Engine struct {
	Model string
}

type Car struct {
	Make   string
	Color  string
	Engine // анонимное поле
}

func main() {
	car := Car{Make: "BMW", Color: "black", Engine: Engine{"S63"}}

	fmt.Println(car.Make, car.Color) // BMW black
	fmt.Println(car.Model) // S63
}
```

## Принцыпы ООП

Основные:
- наследование
- абстракция
- полиморфизм
- инкапсуляция

### Наследование
 -абстрактный тип данных может перенимать свойства и функционал существующего типа. Наследник обладает всеми полями и методами родителя.

В Go нет строгого наследования, оно реализуется через композицию
- способствует повторному использования кода и созданию иерархии классов.
### Абстракция
-Важнейший принцип ООП, выделение важнейших характеристик, игнорирование деалей реализации. Помогает сосредоточится на том что делает объект, не на том как делает.
Абстрактный класс описывает общие характеристики и поведение объектов, а интерфейс описывает сигнатуры методов без реализации.

Преймущеста:
- Упрощает сложные системы
- Способствует гибкости и расширяемости(систему легко дополнить новыми элементами)
- Облегчает повторное использование кода (за счет создания моделей объектов)

### Полиморфизм
-способность объекта(класса или структуры) обрабатывать разные типы данных с использованием общего интерфейса.

виды:
- параметрический - позволяет писать обобщенный код, поддерживающий разные типы данных.
- ad-hoc (интерфейсный) - обьекты разного типа обрабатываются  одинаково вне зависимости от структуры за счет интерфейсов.

в Go полиморфизм реализуется по ad-hoc виду.

! Если определенный тип(стрктура) реализует все методы интерфейса, то он автоматически удовлетворяет ему.

```go
// интерфейс для работы с произвольными животными
// имеет один метод Voice()
type Animals interface {
	Voice()
}

// структура для описания собаки
type Dog struct {
	Name string
}

// структура Dog реализует метод Voice
// и тем самым удовлетворяет интерфейсу Animals
func (d *Dog) Voice() {
	fmt.Printf("%s: Woof\\n", d.Name)
}

// структура для описания кошки
type Cat struct {
	Name string
}

// структура Cat реализует метод Voice
// и тем самым удовлетворяет интерфейсу Animals
func (c *Cat) Voice() {
	fmt.Printf("%s: Meow\\n", c.Name)
}

// функция для вызова метода Voice
func MakeVoice(a Animals) {
	a.Voice()
}

func main() {
	// создание слайса типа Animals с элементами структур Dog и Cat
	animals := []Animals{ 
		&Dog{Name: "Шарик"},
		&Cat{Name: "Мурка"},
	}

	// Вызов методов Voice у объектов слайса Animals
	for _, animal := range animals {
		MakeVoice(animal)
	}
}
```
```StdOut
Шарик: Woof
Мурка: Meow
```

### Инкапсуляция
-объединение данных и метоов работы с ними в один класс и сокрытие деталей реализации. Этот класс должен должен ограничивать доступность полей и позволять взаимодействовать с ними ТОЛЬКО через единый интерфейс.

Для управления доступностью используются модификаторы доступа `public` и `private`.

В Go объекты начинающиеся с заглавной буквы - экспортируемые(public), а с маленькой неэкспортируемые (private) - доступны внутри этого пакета.
Этому правилу подчиняются: функции, переменные, структуры, их поля и методы
```go
type PublicStruct struct { // экспортируемая структура
	PublicField int // экспортируемое поле
}

type privateStruct struct { // неэкспортируемая структура
	privateField int // неэкспортируемое поле
}

var PublicVar // экспортируемая переменная
var privateVar // неэкспортируемая переменная

func PublicFunc() {} // экспортируемая функция
func privateFunc() {} // неэкспортируемая функция
```

## Геттеры и Сеттеры

Для обеспечения контролируемого доступа к данным класса реализуются методы get(SomeValue) и set(someValue). 
По сути являются посредниками между классом и пользователем.

обеспечивают безопасность и конфиденциальность данных и предоставляют инструмент для работы с ними.



### Zero-Links
- [[00 Golang]]
- [[00 Обучение]]


### Links
- https://proglib.io/p/samouchitel-po-go-dlya-nachinayushchih-chast-10-vvedenie-v-oop-nasledovanie-abstrakciya-polimorfizm-inkapsulyaciya-2024-03-11
- /home/zhuk/Labs/go/goLabs/OOP/warehouseManege.go
- 

||||||| (empty tree)
=======
02-06-2025 20:54
Tags: #z #lesson 
# Объектно ориентированное програмирование


Методология програмирования в которой программа это совокупность обьектов реализующие какие-либо методы.
 - обекты являются экземплярами класса
 - классы имеют иерархическую систему наследования признаков и поведения обьектов. (типа как в биологии с животными)

Класс - это набор полей и методов объекта, кототрые описывают его свойства и поведение.

Класс описывает:
- Свойства (атрибуты ) и состояние обьекта
- операции, доступные для взаимодействия с данными(методы)
- Структуры данных обьекта

Объект - экземпляр конкретного класса с заданным состоянием(данными) и поведением(методами)

Новый объект инициализируется функцией конструктором
```go
type Person struct {
		Name string
		age int
}

func NewPerson(name string, age int) *Person { // функция конструктор
	return &Person{
		Name : name,
		Age : age,
	}
}

func main() {
	person1 := NewPerson("Никита", 25) // использование конструктора
}
```
Если не хотим чтобы вызывающая сторона не могла вносить изменения в структуру, возвращаем ее не по указателю а по значению.

# Отношения между объектами

В этом разделе объекты - сущности в программе(классы, структуры и т.д)

Виды отношений:
	is-a(является)
	has-a(иемеет, содержит в себе)

## Ассоциация (has-a)

Ассоциация - отношения между объектами при которых один может вызывать другой, для выполнения действия от его имени. При ассоциации оъекты не связаны, отношения могут быть как однонаправленными, так и двунаправленными(когда оба объекта знают о существовании другого).

### Агрегация (has-a)

Отношение - "часть-целое", один обьект содержит другой, но последний может существовать отдельно. Пример - водитель использует машину, но она может существовать отдельно и иметь несколько владельцев.

Агрегация в Go - встраивание одной структуры в другую в качесве одного из полей. Поля и методы внутренней структуры не доступны через внешнюю.
```go
type Car struct {
	Make string
	Color  string
}

type Driver struct {
	Name string
	Car Car
}

func main() {
	driver := Driver{Name : "Гаджишка", Car{Make : Lada, Color Black}}

	fmt.Println(driver.Name) // Гаджишка
	fmt.Println(driver.Car.Make) // Lada
	fmt.Println(driver.Color) // ошибка (но вообще он такойже черный как его Лада чурка)
}
```

### Композиция (has-a)

Строгая зависимость, при компазиции объекты существуют только в контексте друг друга. Один неотъемлемая часть другого.

Реализуется встраиванием одной структуры в другую, но теперь без явного указания имени. При этом поля внутренней структуры доступны через внешнюю.
```go
type Engine struct {
	Model string
}

type Car struct {
	Make   string
	Color  string
	Engine // анонимное поле
}

func main() {
	car := Car{Make: "BMW", Color: "black", Engine: Engine{"S63"}}

	fmt.Println(car.Make, car.Color) // BMW black
	fmt.Println(car.Model) // S63
}
```

## Принцыпы ООП

Основные:
- наследование
- абстракция
- полиморфизм
- инкапсуляция

### Наследование
 -абстрактный тип данных может перенимать свойства и функционал существующего типа. Наследник обладает всеми полями и методами родителя.

В Go нет строгого наследования, оно реализуется через композицию
- способствует повторному использования кода и созданию иерархии классов.
### Абстракция
-Важнейший принцип ООП, выделение важнейших характеристик, игнорирование деалей реализации. Помогает сосредоточится на том что делает объект, не на том как делает.
Абстрактный класс описывает общие характеристики и поведение объектов, а интерфейс описывает сигнатуры методов без реализации.

Преймущеста:
- Упрощает сложные системы
- Способствует гибкости и расширяемости(систему легко дополнить новыми элементами)
- Облегчает повторное использование кода (за счет создания моделей объектов)

### Полиморфизм
-способность объекта(класса или структуры) обрабатывать разные типы данных с использованием общего интерфейса.

виды:
- параметрический - позволяет писать обобщенный код, поддерживающий разные типы данных.
- ad-hoc (интерфейсный) - обьекты разного типа обрабатываются  одинаково вне зависимости от структуры за счет интерфейсов.

в Go полиморфизм реализуется по ad-hoc виду.

! Если определенный тип(стрkomуктура) реализует все методы интерфейса, то он автоматически удовлетворяет ему.

```go
// интерфейс для работы с произвольными животными
// имеет один метод Voice()
type Animals interface {
	Voice()
}

// структура для описания собаки
type Dog struct {
	Name string
}

// структура Dog реализует метод Voice
// и тем самым удовлетворяет интерфейсу Animals
func (d *Dog) Voice() {
	fmt.Printf("%s: Woof\\n", d.Name)
}

// структура для описания кошки
type Cat struct {
	Name string
}

// структура Cat реализует метод Voice
// и тем самым удовлетворяет интерфейсу Animals
func (c *Cat) Voice() {
	fmt.Printf("%s: Meow\\n", c.Name)
}

// функция для вызова метода Voice
func MakeVoice(a Animals) {
	a.Voice()
}

func main() {
	// создание слайса типа Animals с элементами структур Dog и Cat
	animals := []Animals{ 
		&Dog{Name: "Шарик"},
		&Cat{Name: "Мурка"},
	}

	// Вызов методов Voice у объектов слайса Animals
	for _, animal := range animals {
		MakeVoice(animal)
	}
}
```
```StdOut
Шарик: Woof
Мурка: Meow
```

### Инкапсуляция
-объединение данных и метоов работы с ними в один класс и сокрытие деталей реализации. Этот класс должен должен ограничивать доступность полей и позволять взаимодействовать с ними ТОЛЬКО через единый интерфейс.

Для управления остопностью используются модификаторы доступа `public` и `private`.

В Go объекты начинающиеся с заглавной буквы - экспортируемые(public), а с маленькой неэкспортируемые (private) - доступны внутри этого пакета.
Этому правилу подчиняются: функции, переменные, структуры, их поля и методы
```go
type PublicStruct struct { // экспортируемая структура
	PublicField int // экспортируемое поле
}

type privateStruct struct { // неэкспортируемая структура
	privateField int // неэкспортируемое поле
}

var PublicVar // экспортируемая переменная
var privateVar // неэкспортируемая переменная

func PublicFunc() {} // экспортируемая функция
func privateFunc() {} // неэкспортируемая функция
```

## Геттеры и Сеттеры

Для обеспечения контролируемого доступа к данным класса реализуются методы get(SomeValue) и set(someValue). 
По сути являются посредниками между классом и пользователем.

обеспечивают безопасность и конфиденциальность данных и предоставляют инструмент для работы с ними.



### Zero-Links
- [[00 Golang]]
- [[00 Обучение]]


### Links
- https://proglib.io/p/samouchitel-po-go-dlya-nachinayushchih-chast-10-vvedenie-v-oop-nasledovanie-abstrakciya-polimorfizm-inkapsulyaciya-2024-03-11
- /home/zhuk/Labs/go/goLabs/OOP/warehouseManege.go
- 

>>>>>>> 9d44e37 (first commit down there)
