25-08-2025 18:42
Tags: #z  #lesson #Go 
# Slice или срез

Тип данных - основанный на массиве (см. [[Массив (array)]]), однако имеющий динамическую вместимость.

Слайс является структурой, которая состоит из 3 элементов:
1. pointer: `*array`
2. length: int
3. capacity : int

![[Golang_slice_pic.png]]
Слайс основан на каком-то базавом массиве определенной длины. Слайс указывает на начало массива. Длина от начала слайса до конца базового массива определяет капасити(ёмкость) слайса.  Длина слайса это количесво элементов от начала слайса до конца.

## Append

Функция добавления нового элемента в слайс.
1. новый элемент не добавляется, увеличивается длина слайса и в базавом массиве перезаписывается элемент который был в ячейке на которую увеличилась длина слайса.
2. Длина слайса не может быть больше капасити, это будет означать выход за пределы массива. Если длина равна капасити и требуется добавить еще элементы, тогда создается новый массив в 2 раза больше по размеру, в перую половину копируются данные из слайса, во вторую записываются новые элементы. Переносится указатьель на начало нового массива, старый либо остается либо подчищается сборщиком мусора

## Полезные практики

- Проверять слайс на пустоту лучше через ф-цию `len` а не сравнивая с `nill`
```go
var s1 []int
fmt.Println(len(s1) == 0)
```
функции, которые работают со слайсами длжны кореектно отрабатывать с нулевыми слайсами

- по возможности аллоцировать память для слайса
```go
func main() {
	list := make([]int{1, 2, 3, 4, 8})

	fmt.Println(double(list))
}

func double(nums []int) []int {
	res := make([]int, 0, len(nums)) // капасити = длина вход слайса

	for_, num := range nums {
		res = append(res, num*2)
	}
}
```

- Если  мы хотим изменить переданный в функцию слайс, но не хотим, чтобы не изменился внешний следует создать копию того слайса внутри функции.

-  результат работы функции append  всегда присваиваем той же переменной





### Zero-Links
- [[00 Обучение]]
- [[00 Golang]]


### Links
- https://youtu.be/10LW7NROfOQ?si=J40bqLkpaDbjo8Dm
- 
